This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-09T17:26:36.401Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
models/
  modelsDEA.py
  modelsFDH.py
  modelsNH.py
utils/
  datainput.py
  groupDMUs.py
  is_efficient.py
  li_test.py
1i1o.csv
2i1o.csv

================================================================
Files
================================================================

================
File: models/modelsDEA.py
================
from gurobipy import Model, GRB, quicksum
import pandas as pd
import numpy as np

from utils.is_efficient import is_efficient 
import pickle
import matplotlib.pyplot as plt
from scipy.spatial import ConvexHull
from mpl_toolkits.mplot3d import Axes3D

class DEA:
    def __init__(self, input_data, output_data, dmu_names=None, input_feature_names=None, output_feature_names=None): 
        self.input_data = np.asarray(input_data)
        self.output_data = np.asarray(output_data)

        if self.input_data.ndim == 1:
            self.input_data = self.input_data.reshape(-1, 1)
        if self.output_data.ndim == 1:
            self.output_data = self.output_data.reshape(-1, 1)

        self.n, self.m = self.input_data.shape
        if self.output_data.shape[0] != self.n:
            raise ValueError("Input and output data must have the same number of DMUs (rows).")
        self.s = self.output_data.shape[1]
        self.results = {}

        self.set_dmu_names(dmu_names)
        self.set_input_feature_names(input_feature_names)
        self.set_output_feature_names(output_feature_names)

    def set_dmu_names(self, names_list):
        if names_list is None:
            self.dmu_names = [f"DMU_{i+1}" for i in range(self.n)]
        elif len(names_list) == self.n:
            self.dmu_names = list(names_list)
        else:
            raise ValueError(f"DMU names list length must be {self.n}, but got {len(names_list)}")

    def _get_dmu_name(self, index): 
        return self.dmu_names[index]

    def set_input_feature_names(self, names_list):
        if names_list is None:
            self.input_feature_names = [f"Input_{i+1}" for i in range(self.m)]
        elif len(names_list) == self.m:
            self.input_feature_names = list(names_list)
        else:
            raise ValueError(f"Input feature names list length must be {self.m}, but got {len(names_list)}")

    def set_output_feature_names(self, names_list):
        if names_list is None:
            self.output_feature_names = [f"Output_{i+1}" for i in range(self.s)]
        elif len(names_list) == self.s:
            self.output_feature_names = list(names_list)
        else:
            raise ValueError(f"Output feature names list length must be {self.s}, but got {len(names_list)}")

    def save_results(self, file_path):
        if not file_path:
            print("Save operation canceled: No file path provided.")
            return
        if not file_path.lower().endswith(".pkl"):
            file_path += ".pkl"

        with open(file_path, "wb") as file:
            pickle.dump(self.results, file)
        print(f"Results saved to {file_path}")

    def ccr_input_p1(self):
        efficiencies = []
        for o in range(self.n):
            model = Model("InputEfficiency_CCR_P1")
            model.setParam(GRB.Param.OutputFlag, 0)
            lambdas = [model.addVar(lb=0, name=f"lambda_{j}") for j in range(self.n)]
            theta = model.addVar(lb=0, name="theta")
            model.setObjective(theta, GRB.MINIMIZE)
            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) <= theta * self.input_data[o, i])
            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) >= self.output_data[o, r])
            model.optimize()
            efficiencies.append(model.objVal if model.status == GRB.OPTIMAL else np.nan)
        return efficiencies

    def ccr_input_p2(self, input_efficiencies):
        results_list = [] 
        for o in range(self.n):
            theta_star = input_efficiencies[o]
            if np.isnan(theta_star):
                results_list.append({
                    'DMU': o, 'DMU_Name': self._get_dmu_name(o), 'efficiency': np.nan,
                    'slacks_minus': [np.nan]*self.m, 'slacks_plus': [np.nan]*self.s, 'Lambda': [np.nan]*self.n
                })
                continue

            model = Model("Phase2_CCR_Input")
            model.setParam(GRB.Param.OutputFlag, 0)
            lambdas = [model.addVar(lb=0, name=f"lambda_{j}") for j in range(self.n)]
            S_minus = [model.addVar(lb=0, name=f"S_minus_{i}") for i in range(self.m)]
            S_plus = [model.addVar(lb=0, name=f"S_plus_{r}") for r in range(self.s)]
            model.setObjective(quicksum(S_minus) + quicksum(S_plus), GRB.MAXIMIZE)
            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) + S_minus[i] == theta_star * self.input_data[o, i])
            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) - S_plus[r] >= self.output_data[o, r])
            model.optimize()

            if model.status == GRB.OPTIMAL:
                results_list.append({
                    'DMU': o,
                    'DMU_Name': self._get_dmu_name(o), 
                    'efficiency': theta_star,
                    'slacks_minus': [S_minus[i].x for i in range(self.m)],
                    'slacks_plus': [S_plus[r].x for r in range(self.s)],
                    'Lambda': [lambdas[j].x for j in range(self.n)]
                })
            else: 
                results_list.append({
                    'DMU': o, 'DMU_Name': self._get_dmu_name(o), 'efficiency': theta_star, 
                    'slacks_minus': [np.nan]*self.m, 'slacks_plus': [np.nan]*self.s, 'Lambda': [np.nan]*self.n
                })
        return pd.DataFrame(results_list)

    def ccr_input(self):
        if "ccr_input" in self.results:
            return self.results['ccr_input']

        results_df = self.ccr_input_p2(self.ccr_input_p1()) 
        results_df = is_efficient(results_df, 'ccr_input')
        self.results['ccr_input'] = results_df
        return results_df

    def ccr_output(self):
        if "ccr_output" in self.results:
            return self.results['ccr_output']

        if "ccr_input" not in self.results:
            self.ccr_input() 

        base_results_df = self.results['ccr_input']
        if base_results_df is None or base_results_df.empty: 

            print("Error: CCR_Input results are not available or invalid for CCR_Output computation.")
            return pd.DataFrame() 

        results_df = base_results_df.copy() 

        results_df['n_val'] = np.nan
        results_df['slacks_minus_transformed'] = None
        results_df['slacks_plus_transformed'] = None
        results_df['Lambda_transformed'] = None

        for i in range(self.n):
            if pd.isna(results_df.loc[i, 'efficiency']) or results_df.loc[i, 'efficiency'] == 0:
                n_val = np.inf 
            else:
                n_val = 1 / results_df.loc[i, 'efficiency']
            results_df.loc[i, 'n_val'] = n_val

            if not pd.isna(n_val):
                results_df.at[i, 'slacks_minus_transformed'] = [val * n_val for val in results_df.loc[i, 'slacks_minus']]
                results_df.at[i, 'slacks_plus_transformed'] = [val * n_val for val in results_df.loc[i, 'slacks_plus']]
                results_df.at[i, 'Lambda_transformed'] = [val * n_val for val in results_df.loc[i, 'Lambda']]
            else: 
                results_df.at[i, 'slacks_minus_transformed'] = [np.nan] * self.m
                results_df.at[i, 'slacks_plus_transformed'] = [np.nan] * self.s
                results_df.at[i, 'Lambda_transformed'] = [np.nan] * self.n

        output_columns = ['DMU', 'DMU_Name']
        results_df_transformed = results_df[output_columns].copy()
        results_df_transformed['n'] = results_df['n_val']
        results_df_transformed['t_minus'] = results_df['slacks_minus_transformed']
        results_df_transformed['t_plus'] = results_df['slacks_plus_transformed']
        results_df_transformed['u'] = results_df['Lambda_transformed']

        results_df_transformed = is_efficient(results_df_transformed, 'ccr_output')
        self.results['ccr_output'] = results_df_transformed
        return results_df_transformed

    def bcc_input_p1(self):
        efficiencies = []
        for o in range(self.n):
            model = Model("InputEfficiency_BCC_P1")
            model.setParam(GRB.Param.OutputFlag, 0)
            lambdas = [model.addVar(lb=0, name=f"lambda_{j}") for j in range(self.n)]
            theta = model.addVar(lb=0, name="theta")
            model.setObjective(theta, GRB.MINIMIZE)
            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) <= theta * self.input_data[o, i])
            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) >= self.output_data[o, r])
            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)
            model.optimize()
            efficiencies.append(model.objVal if model.status == GRB.OPTIMAL else np.nan)
        return efficiencies

    def bcc_input_p2(self, input_efficiencies):
        results_list = []
        for o in range(self.n):
            theta_star = input_efficiencies[o]
            if np.isnan(theta_star):
                results_list.append({
                    'DMU': o, 'DMU_Name': self._get_dmu_name(o), 'efficiency': np.nan,
                    'slacks_minus': [np.nan]*self.m, 'slacks_plus': [np.nan]*self.s, 'Lambda': [np.nan]*self.n
                })
                continue

            model = Model("Phase2_BCC_Input")
            model.setParam(GRB.Param.OutputFlag, 0)
            lambdas = [model.addVar(lb=0, name=f"lambda_{j}") for j in range(self.n)]
            S_minus = [model.addVar(lb=0, name=f"S_minus_{i}") for i in range(self.m)]
            S_plus = [model.addVar(lb=0, name=f"S_plus_{r}") for r in range(self.s)]
            model.setObjective(quicksum(S_minus) + quicksum(S_plus), GRB.MAXIMIZE)
            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) + S_minus[i] == theta_star * self.input_data[o, i])
            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) - S_plus[r] >= self.output_data[o, r])
            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)
            model.optimize()

            if model.status == GRB.OPTIMAL:
                results_list.append({
                    'DMU': o,
                    'DMU_Name': self._get_dmu_name(o), 
                    'efficiency': theta_star,
                    'slacks_minus': [S_minus[i].x for i in range(self.m)],
                    'slacks_plus': [S_plus[r].x for r in range(self.s)],
                    'Lambda': [lambdas[j].x for j in range(self.n)]
                })
            else:
                 results_list.append({
                    'DMU': o, 'DMU_Name': self._get_dmu_name(o), 'efficiency': theta_star,
                    'slacks_minus': [np.nan]*self.m, 'slacks_plus': [np.nan]*self.s, 'Lambda': [np.nan]*self.n
                })
        return pd.DataFrame(results_list)

    def bcc_input(self):
        if "bcc_input" in self.results:
            return self.results['bcc_input']
        results_df = self.bcc_input_p2(self.bcc_input_p1())
        results_df = is_efficient(results_df, 'bcc_input')
        self.results['bcc_input'] = results_df
        return results_df

    def bcc_output_p1(self):
        efficiencies = []
        for o in range(self.n):
            model = Model("OutputEfficiency_BCC_P1")
            model.setParam(GRB.Param.OutputFlag, 0)
            lambdas = [model.addVar(lb=0, name=f"lambdas_{j}") for j in range(self.n)]
            eta = model.addVar(lb=1, name="eta") 
            model.setObjective(eta, GRB.MAXIMIZE)
            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) <= self.input_data[o, i])
            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) >= eta * self.output_data[o, r])
            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)
            model.optimize()
            efficiencies.append(model.objVal if model.status == GRB.OPTIMAL else np.nan)
        return efficiencies

    def bcc_output_p2(self, output_efficiencies):
        results_list = []
        for o in range(self.n):
            eta_star = output_efficiencies[o]
            if np.isnan(eta_star):
                results_list.append({
                    'DMU': o, 'DMU_Name': self._get_dmu_name(o), 'efficiency': np.nan,
                    'slacks_minus': [np.nan]*self.m, 'slacks_plus': [np.nan]*self.s, 'Lambda': [np.nan]*self.n
                })
                continue

            model = Model("Phase2_BCC_Output")
            model.setParam(GRB.Param.OutputFlag, 0)
            lambdas = [model.addVar(lb=0, name=f"lambda_{j}") for j in range(self.n)]
            S_minus = [model.addVar(lb=0, name=f"S_minus_{i}") for i in range(self.m)]
            S_plus = [model.addVar(lb=0, name=f"S_plus_{r}") for r in range(self.s)]
            model.setObjective(quicksum(S_minus) + quicksum(S_plus), GRB.MAXIMIZE)
            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) + S_minus[i] == self.input_data[o, i])
            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) - S_plus[r] >= eta_star * self.output_data[o, r])
            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)
            model.optimize()

            if model.status == GRB.OPTIMAL:
                results_list.append({
                    'DMU': o,
                    'DMU_Name': self._get_dmu_name(o), 
                    'efficiency': eta_star, 
                    'slacks_minus': [S_minus[i].x for i in range(self.m)], 
                    'slacks_plus': [S_plus[r].x for r in range(self.s)], 
                    'Lambda': [lambdas[j].x for j in range(self.n)] 
                })
            else:
                results_list.append({
                    'DMU': o, 'DMU_Name': self._get_dmu_name(o), 'efficiency': eta_star,
                    'slacks_minus': [np.nan]*self.m, 'slacks_plus': [np.nan]*self.s, 'Lambda': [np.nan]*self.n
                })
        return pd.DataFrame(results_list)

    def bcc_output(self):
        if "bcc_output" in self.results:
            return self.results['bcc_output']
        results_df = self.bcc_output_p2(self.bcc_output_p1())
        results_df.rename(columns={
            'efficiency': 'n', 
            'slacks_minus': 't_minus',
            'slacks_plus':'t_plus',
            'Lambda':'u'}, inplace=True)
        results_df = is_efficient(results_df, 'bcc_output')
        self.results['bcc_output'] = results_df
        return results_df

    def add(self):
        if "add" in self.results:
            return self.results['add']
        results_list = []
        for o in range(self.n):
            model = Model("AdditiveModel")
            model.setParam(GRB.Param.OutputFlag, 0)
            lambdas = [model.addVar(lb=0, name=f"lambda_{j}") for j in range(self.n)]
            S_minus = [model.addVar(lb=0, name=f"S_minus_{i}") for i in range(self.m)]
            S_plus = [model.addVar(lb=0, name=f"S_plus_{r}") for r in range(self.s)]
            model.setObjective(quicksum(S_minus) + quicksum(S_plus), GRB.MAXIMIZE)
            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) + S_minus[i] == self.input_data[o, i])
            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) - S_plus[r] == self.output_data[o, r])
            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)
            model.optimize()

            if model.status == GRB.OPTIMAL:
                results_list.append({
                    'DMU': o,
                    'DMU_Name': self._get_dmu_name(o), 
                    'slacks_minus': [S_minus[i].x for i in range(self.m)],
                    'slacks_plus': [S_plus[r].x for r in range(self.s)],
                    'Lambda': [lambdas[j].x for j in range(self.n)]
                })
            else:
                results_list.append({
                    'DMU': o, 'DMU_Name': self._get_dmu_name(o),
                    'slacks_minus': [np.nan]*self.m, 'slacks_plus': [np.nan]*self.s, 'Lambda': [np.nan]*self.n
                })

        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, 'add')
        self.results['add'] = results_df
        return results_df

    def sbm_non_oriented(self, crs=True): 
        model_type_str = f"sbm_non_oriented_{'crs' if crs else 'vrs'}"
        if model_type_str in self.results:
            return self.results[model_type_str]

        results_list = [] 
        for o in range(self.n):
            model = Model(f"SBM_NonOriented_DMU{o}") 
            model.setParam(GRB.Param.OutputFlag, 0)

            Lambda_vars = [model.addVar(lb=0, name=f"Lambda_{j}") for j in range(self.n)] 
            S_minus = [model.addVar(lb=0, name=f"S_minus_{i}") for i in range(self.m)]
            S_plus = [model.addVar(lb=0, name=f"S_plus_{r}") for r in range(self.s)]
            t_var = model.addVar(lb=1e-9, name="t") 

            obj_terms_s_minus = []
            active_inputs_count = 0
            for i in range(self.m):
                if self.input_data[o, i] > 1e-9: 
                    obj_terms_s_minus.append(S_minus[i] / self.input_data[o, i])
                    active_inputs_count += 1
                else: 
                    model.addConstr(S_minus[i] == 0)

            constr_terms_s_plus = []
            active_outputs_count = 0
            for r in range(self.s):
                if self.output_data[o, r] > 1e-9: 
                    constr_terms_s_plus.append(S_plus[r] / self.output_data[o, r])
                    active_outputs_count += 1
                else: 
                     model.addConstr(S_plus[r] == 0)

            if active_inputs_count > 0:
                model.setObjective(t_var - (1/active_inputs_count) * quicksum(obj_terms_s_minus), GRB.MINIMIZE)
            else: 
                model.setObjective(t_var, GRB.MINIMIZE) 

            if active_outputs_count > 0:
                model.addConstr(t_var + (1/active_outputs_count) * quicksum(constr_terms_s_plus) == 1)
            else: 
                model.addConstr(t_var == 1)

            for i in range(self.m):
                model.addConstr(quicksum(Lambda_vars[j] * self.input_data[j, i] for j in range(self.n)) + S_minus[i] == t_var * self.input_data[o, i] )
            for r in range(self.s):
                model.addConstr(quicksum(Lambda_vars[j] * self.output_data[j, r] for j in range(self.n)) - S_plus[r] == t_var * self.output_data[o, r] )

            if not crs:
                model.addConstr(quicksum(Lambda_vars) == t_var)

            model.optimize()

            if model.status == GRB.OPTIMAL:
                rho_star = model.objVal
                t_star_val = t_var.x
                if abs(t_star_val) < 1e-9 : t_star_val = 1e-9 

                lambda_star = [Lambda_vars[j].x / t_star_val for j in range(self.n)]
                s_minus_star_orig = [S_minus[i].x / t_star_val for i in range(self.m)] 
                s_plus_star_orig = [S_plus[r].x / t_star_val for r in range(self.s)]   
            else:
                rho_star, t_star_val = np.nan, np.nan
                lambda_star = [np.nan]*self.n
                s_minus_star_orig = [np.nan]*self.m
                s_plus_star_orig = [np.nan]*self.s

            results_list.append({
                'DMU': o, 'DMU_Name': self._get_dmu_name(o), 
                'rho': rho_star, 'lambda': lambda_star, 
                's_minus': s_minus_star_orig, 's_plus': s_plus_star_orig, 
                'S_minus_transformed': [S_minus[i].x if model.status == GRB.OPTIMAL else np.nan for i in range(self.m)], 
                'S_plus_transformed': [S_plus[r].x if model.status == GRB.OPTIMAL else np.nan for r in range(self.s)],   
                't_star': t_star_val
            })
        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, 'sbm_non_oriented') 
        self.results[model_type_str] = results_df
        return results_df

    def sbm_input(self, crs=True):
        model_type_str = f"sbm_input_{'crs' if crs else 'vrs'}"
        if model_type_str in self.results:
            return self.results[model_type_str]

        results_list = []
        for o in range(self.n):
            model = Model(f"SBM_Input_DMU{o}")
            model.setParam(GRB.Param.OutputFlag, 0)
            Lambda_vars = [model.addVar(lb=0, name=f"Lambda_{j}") for j in range(self.n)]
            S_minus = [model.addVar(lb=0, name=f"S_minus_{i}") for i in range(self.m)]

            S_plus = [model.addVar(lb=0, ub=0, name=f"S_plus_{r}") for r in range(self.s)] 
            t_var = model.addVar(lb=1e-9, name="t")

            obj_terms_s_minus = []
            active_inputs_count = 0
            for i in range(self.m):
                if self.input_data[o, i] > 1e-9:
                    obj_terms_s_minus.append(S_minus[i] / self.input_data[o, i])
                    active_inputs_count += 1
                else:
                    model.addConstr(S_minus[i] == 0) 

            if active_inputs_count > 0:
                model.setObjective(t_var - (1 / active_inputs_count) * quicksum(obj_terms_s_minus), GRB.MINIMIZE)
            else: 
                model.setObjective(t_var, GRB.MINIMIZE) 

            model.addConstr(t_var == 1)

            for i in range(self.m):
                model.addConstr(quicksum(Lambda_vars[j] * self.input_data[j, i] for j in range(self.n)) + S_minus[i] == t_var * self.input_data[o, i])
            for r in range(self.s):
                model.addConstr(quicksum(Lambda_vars[j] * self.output_data[j, r] for j in range(self.n)) >= t_var * self.output_data[o, r])

            if not crs: 
                model.addConstr(quicksum(Lambda_vars) == t_var)

            model.optimize()

            if model.status == GRB.OPTIMAL:
                rho_star = model.objVal 
                t_star_val = t_var.x 
                lambda_star = [Lambda_vars[j].x / t_star_val for j in range(self.n)]
                s_minus_star_orig = [S_minus[i].x / t_star_val for i in range(self.m)]
                s_plus_star_orig = [0.0 for _ in range(self.s)] 
            else:
                rho_star, t_star_val = np.nan, np.nan
                lambda_star = [np.nan] * self.n
                s_minus_star_orig = [np.nan] * self.m
                s_plus_star_orig = [np.nan] * self.s

            results_list.append({
                'DMU': o, 'DMU_Name': self._get_dmu_name(o),
                'rho': rho_star, 'lambda': lambda_star,
                's_minus': s_minus_star_orig, 's_plus': s_plus_star_orig,
                'S_minus_transformed': [S_minus[i].x if model.status == GRB.OPTIMAL else np.nan for i in range(self.m)],
                'S_plus_transformed': [S_plus[r].x if model.status == GRB.OPTIMAL else np.nan for r in range(self.s)], 
                't_star': t_star_val
            })
        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, 'sbm_input')
        self.results[model_type_str] = results_df
        return results_df

    def sbm_output(self, crs=True):
        model_type_str = f"sbm_output_{'crs' if crs else 'vrs'}"
        if model_type_str in self.results:
            return self.results[model_type_str]

        results_list = []
        for o in range(self.n):
            model = Model(f"SBM_Output_DMU{o}")
            model.setParam(GRB.Param.OutputFlag, 0)
            Lambda_vars = [model.addVar(lb=0, name=f"Lambda_{j}") for j in range(self.n)]

            S_minus = [model.addVar(lb=0, ub=0, name=f"S_minus_{i}") for i in range(self.m)]
            S_plus = [model.addVar(lb=0, name=f"S_plus_{r}") for r in range(self.s)]
            t_var = model.addVar(lb=1e-9, name="t")

            model.setObjective(t_var, GRB.MINIMIZE)

            constr_terms_s_plus = []
            active_outputs_count = 0
            for r in range(self.s):
                if self.output_data[o, r] > 1e-9:
                    constr_terms_s_plus.append(S_plus[r] / self.output_data[o, r])
                    active_outputs_count += 1
                else: 
                    model.addConstr(S_plus[r] == 0)

            if active_outputs_count > 0:
                model.addConstr(t_var + (1 / active_outputs_count) * quicksum(constr_terms_s_plus) == 1)
            else:
                model.addConstr(t_var == 1)

            for i in range(self.m):

                model.addConstr(quicksum(Lambda_vars[j] * self.input_data[j, i] for j in range(self.n)) <= t_var * self.input_data[o, i])

            for r in range(self.s):
                model.addConstr(quicksum(Lambda_vars[j] * self.output_data[j, r] for j in range(self.n)) - S_plus[r] == t_var * self.output_data[o, r])

            if not crs: 
                model.addConstr(quicksum(Lambda_vars) == t_var)

            model.optimize()

            if model.status == GRB.OPTIMAL:
                rho_star = model.objVal 
                t_star_val = t_var.x 

                lambda_star = [Lambda_vars[j].x / t_star_val for j in range(self.n)]
                s_minus_star_orig = [0.0 for _ in range(self.m)] 
                s_plus_star_orig = [S_plus[r].x / t_star_val for r in range(self.s)]
            else:
                rho_star, t_star_val = np.nan, np.nan
                lambda_star = [np.nan] * self.n
                s_minus_star_orig = [np.nan] * self.m
                s_plus_star_orig = [np.nan] * self.s

            results_list.append({
                'DMU': o, 'DMU_Name': self._get_dmu_name(o),
                'rho': rho_star, 'lambda': lambda_star,
                's_minus': s_minus_star_orig, 's_plus': s_plus_star_orig,
                'S_minus_transformed': [S_minus[i].x if model.status == GRB.OPTIMAL else np.nan for i in range(self.m)], 
                'S_plus_transformed': [S_plus[r].x if model.status == GRB.OPTIMAL else np.nan for r in range(self.s)],
                't_star': t_star_val
            })
        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, 'sbm_output')
        self.results[model_type_str] = results_df
        return results_df

    def modified_sbm(self):
        if "modified_sbm" in self.results: 
            return self.results['modified_sbm']

        results_list = []

        min_inputs = np.min(self.input_data, axis=0)
        max_outputs = np.max(self.output_data, axis=0)

        P_minus_all = self.input_data - min_inputs
        P_plus_all = max_outputs - self.output_data

        for o in range(self.n): 
            model = Model("ModifiedSBM_Model")
            model.setParam(GRB.Param.OutputFlag, 0)

            Lambda_vars = [model.addVar(lb=0, name=f"Lambda_{j}") for j in range(self.n)]
            S_minus = [model.addVar(lb=0, name=f"S_minus_{i}") for i in range(self.m)]
            S_plus = [model.addVar(lb=0, name=f"S_plus_{r}") for r in range(self.s)]
            t_var = model.addVar(lb=1e-6, name="t") 

            P_minus_o = P_minus_all[o, :]
            P_plus_o = P_plus_all[o, :]

            objective_terms = []
            num_active_input_ranges = 0
            for i in range(self.m):
                if P_minus_o[i] > 1e-9: 
                    objective_terms.append(S_minus[i] / P_minus_o[i])
                    num_active_input_ranges +=1
                else: 
                    model.addConstr(S_minus[i] == 0)

            if num_active_input_ranges > 0:
                 model.setObjective(t_var - quicksum(objective_terms) / num_active_input_ranges, GRB.MINIMIZE)
            else: 
                 model.setObjective(t_var, GRB.MINIMIZE)

            constraint_terms = []
            num_active_output_ranges = 0
            for r in range(self.s):
                if P_plus_o[r] > 1e-9: 
                    constraint_terms.append(S_plus[r] / P_plus_o[r])
                    num_active_output_ranges +=1
                else: 
                    model.addConstr(S_plus[r] == 0)

            if num_active_output_ranges > 0:
                model.addConstr(t_var + quicksum(constraint_terms) / num_active_output_ranges == 1)
            else: 
                model.addConstr(t_var == 1)

            for i in range(self.m):

                model.addConstr(quicksum(Lambda_vars[j] * P_minus_all[j, i] for j in range(self.n)) == \
                                t_var * P_minus_o[i] - S_minus[i])

            for r in range(self.s):

                model.addConstr(quicksum(Lambda_vars[j] * P_plus_all[j, r] for j in range(self.n)) == \
                                t_var * P_plus_o[r] + S_plus[r])

            model.addConstr(quicksum(Lambda_vars[j] for j in range(self.n)) == t_var)

            model.optimize()

            if model.status == GRB.OPTIMAL:
                rho_star = model.objVal
                t_star = t_var.x

                if abs(t_star) < 1e-9 : t_star = 1e-9 

                lambda_star = [Lambda_vars[j].x / t_star for j in range(self.n)]
                s_minus_star = [S_minus[i].x / t_star for i in range(self.m)]
                s_plus_star = [S_plus[r].x / t_star for r in range(self.s)]
            else:
                rho_star, t_star = np.nan, np.nan
                lambda_star, s_minus_star, s_plus_star = [np.nan]*self.n, [np.nan]*self.m, [np.nan]*self.s

            results_list.append({
                'DMU': o, 'DMU_Name': self._get_dmu_name(o),
                'rho': rho_star, 'lambda': lambda_star,
                's_minus': s_minus_star, 's_plus': s_plus_star,
                't_star': t_star 
            })

        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, 'modified_sbm') 
        self.results['modified_sbm'] = results_df
        return results_df

    def rdm(self):
        if "rdm" in self.results:
            return self.results['rdm']
        results_list = [] 

        min_inputs_overall = np.min(self.input_data, axis=0)
        max_outputs_overall = np.max(self.output_data, axis=0)

        for o in range(self.n):
            model = Model("RDM_Model")
            model.setParam(GRB.Param.OutputFlag, 0)

            R_minus_o = self.input_data[o, :] - min_inputs_overall
            R_plus_o = max_outputs_overall - self.output_data[o, :]

            lambdas = [model.addVar(lb=0, name=f"lambda_{j}") for j in range(self.n)]
            beta = model.addVar(lb=0, ub=1, name="beta") 

            model.setObjective(1 - beta, GRB.MINIMIZE)

            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) <= self.input_data[o, i] - beta * R_minus_o[i])
            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) >= self.output_data[o, r] + beta * R_plus_o[r])

            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)
            model.optimize()

            efficiency_val = np.nan
            if model.status == GRB.OPTIMAL:
                efficiency_val = model.ObjVal 
                if abs(efficiency_val) < 1e-9: efficiency_val = 0.0
                if abs(efficiency_val - 1.0) < 1e-9: efficiency_val = 1.0

            results_list.append({
                "DMU": o, "DMU_Name": self._get_dmu_name(o), 
                "efficiency": efficiency_val
            })
        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, 'rdm')
        self.results['rdm'] = results_df
        return results_df

    def plot2d(self, typ):
        if typ in self.results:
            print(f"Results for model '{typ}' are already computed. Skipping plot.")

        if self.input_data.shape[1] != 1 or self.output_data.shape[1] != 1:
            raise ValueError("Unsupported combination of M and S")

        fig, ax = plt.subplots(figsize=(8, 6))
        x = self.input_data.flatten()
        y = self.output_data.flatten()
        ax.scatter(x, y, c='blue', label='DMUs')
        ax.set_xlabel('Input')
        ax.set_ylabel('Output')
        title = 'Input vs Output'
        fake_origin = (np.min(x), np.max(y))
        max_x, max_y = np.max(x), np.max(y)

        typ2func = {
            'ccr_input': self.ccr_input,  
            'ccr_output': self.ccr_output,
            'sbm_non_oriented': self.sbm_non_oriented,
            'sbm_non_oriented_vrs': self.sbm_non_oriented(crs=False),
            'sbm_non_oriented_crs': self.sbm_non_oriented(crs=True),
            'add': self.add,
            'bcc_input': self.bcc_input,
            'bcc_output': self.bcc_output,
        }

        if typ not in typ2func:
            print(f"Unsupported type: {typ}")
            return

        if typ not in self.results:
            print(f"Calculating results for {typ}...")
            results = typ2func[typ]()  
        else:
            print(f"Using cached results for {typ}...")
            results = self.results[typ]  

        efficient_points = []

        for i, efficient in enumerate(results['is_efficient']):
            dmu_name = self._get_dmu_name(i)
            ax.text(x[i], y[i], dmu_name, color='gray', fontsize=9, ha='right', va='bottom')
            if efficient:
                efficient_points.append((x[i], y[i]))
                circle = plt.Circle((x[i], y[i]), radius=0.05, fill=False, ec='red', lw=1.5)
                ax.add_patch(circle)

        if len(efficient_points) > 2:
            hull = ConvexHull(efficient_points)
            edges = []
            for simplex in hull.simplices:
                edge = (efficient_points[simplex[0]], efficient_points[simplex[1]])
                dist = self.perpendicular_distance(fake_origin, edge[0], edge[1])
                edges.append((edge, dist))
            edges.sort(key=lambda x: x[1])
            selected_edges = edges[:len(efficient_points) - 1]
            for edge, _ in selected_edges:
                ax.plot([edge[0][0], edge[1][0]], [edge[0][1], edge[1][1]], 'r-', linewidth=2)
        elif len(efficient_points) == 2:
            ax.plot([efficient_points[0][0], efficient_points[1][0]],
                    [efficient_points[0][1], efficient_points[1][1]], 'r-', linewidth=2)
        elif len(efficient_points) == 1:
            extended_point = self.extend_line((0, 0), efficient_points[0], max_x)
            ax.plot([0, extended_point[0]], [0, extended_point[1]], 'r-', linewidth=2)

        ax.set_xlim(0, max_x * 1.1)
        ax.set_ylim(0, max_y * 1.1)
        ax.set_title(title)
        ax.grid(True, linestyle='--', alpha=0.5)
        plt.tight_layout()
        # plt.show()
        return fig  # Return the figure instead of showing it

    def plot3d(self, typ):
        fig = plt.figure()

        N, M = self.input_data.shape
        N, S = self.output_data.shape

        if M == 1 and S == 1:
            raise ValueError("Exactally 3 axes required")

        elif M == 2 and S == 1:
            ax = fig.add_subplot(111, projection='3d')
            x = self.input_data[:, 0]
            y = self.input_data[:, 1]
            z = self.output_data.flatten()
            ax.scatter(x, y, z, c='green')
            ax.set_xlabel('Input1')
            ax.set_ylabel('Input2')
            ax.set_zlabel('Output')
            title = 'Input1 vs Input2 vs Output'

        elif M == 1 and S == 2:
            ax = fig.add_subplot(111, projection='3d')
            x = self.input_data.flatten()
            y = self.output_data[:, 0]
            z = self.output_data[:, 1]
            ax.scatter(x, y, z, c='red')
            ax.set_xlabel('Input')
            ax.set_ylabel('Output1')
            ax.set_zlabel('Output2')
            title = 'Input vs Output1 vs Output2'

        else:
            raise ValueError("Unsupported combination of M and S")

        typ2func = {
            'ccr_input': self.ccr_input,  
            'ccr_output': self.ccr_output,
            'sbm_non_oriented_vrs': self.sbm_non_oriented(crs=False),
            'sbm_non_oriented_crs': self.sbm_non_oriented(crs=True),
            'add': self.add,
            'bcc_input': self.bcc_input,
            'bcc_output': self.bcc_output,
        }

        if typ not in typ2func:
            print(f"Unsupported type: {typ}")
            return

        if typ not in self.results:
            print(f"Calculating results for {typ}...")
            res = typ2func[typ]()  
            self.results[typ] = res  
        else:
            print(f"Using cached results for {typ}...")
            res = self.results[typ]  

        efficiency_data = res  
        if 'is_efficient' in efficiency_data.columns:
            is_efficient = efficiency_data['is_efficient'].values
        else:
            print(f"Warning: 'is_efficient' column missing in results for {typ}")
            return

        for i, efficient in enumerate(is_efficient):
            if efficient:
                ax.scatter(x[i], y[i], z[i], s=200, facecolors='none', edgecolors='r', linewidths=2)
                dmu_name = self._get_dmu_name(i)
                ax.text(x[i], y[i], z[i] + 0.02, dmu_name, color='gray', fontsize=10, ha='center')

        # for i, efficient in enumerate(is_efficient):
        #     if efficient:
        #         ax.scatter(x[i], y[i], z[i], s=200, facecolors='none', edgecolors='r', linewidths=2)
        #         ax.text(x[i], y[i], z[i] + 0.02, typ, color='black', fontsize=10, ha='center')

        ax.set_title(title)
        ax.grid(True)
        # plt.show()
        return fig  # Return the figure instead of showing it




#####################################################################################


    def perpendicular_distance(self, point, line_point1, line_point2):
        x0, y0 = point
        x1, y1 = line_point1
        x2, y2 = line_point2
        return abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / np.sqrt((y2 - y1)**2 + (x2 - x1)**2)

    def extend_line(self, p1, p2, max_x):
        if p2[0] == p1[0]:  
            return (p2[0], max_x * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1])
        else:
            slope = (p2[1] - p1[1]) / (p2[0] - p1[0])
            return (max_x, slope * (max_x - p1[0]) + p1[1])

================
File: models/modelsFDH.py
================
from gurobipy import Model, GRB, quicksum
import pandas as pd
import numpy as np
from utils.is_efficient import is_efficient 
import pickle
import matplotlib.pyplot as plt

class FDH:
    def __init__(self, input_data, output_data, dmu_names=None, input_feature_names=None, output_feature_names=None):
        self.input_data = np.asarray(input_data)
        self.output_data = np.asarray(output_data)

        if self.input_data.ndim == 1:
            self.input_data = self.input_data.reshape(-1, 1)
        if self.output_data.ndim == 1:
            self.output_data = self.output_data.reshape(-1, 1)

        self.n, self.m = self.input_data.shape
        if self.output_data.shape[0] != self.n:
            raise ValueError("Input and output data must have the same number of DMUs (rows).")
        self.s = self.output_data.shape[1]
        self.results = {}

        self.set_dmu_names(dmu_names)
        self.set_input_feature_names(input_feature_names)
        self.set_output_feature_names(output_feature_names)

    def set_dmu_names(self, names_list):
        if names_list is None:
            self.dmu_names = [f"DMU_{i+1}" for i in range(self.n)] 
        elif len(names_list) == self.n:
            self.dmu_names = list(names_list)
        else:
            raise ValueError(f"DMU names list length must be {self.n}, but got {len(names_list)}")

    def _get_dmu_name(self, index):
        return self.dmu_names[index]

    def set_input_feature_names(self, names_list):
        if names_list is None:
            self.input_feature_names = [f"Input_{i+1}" for i in range(self.m)]
        elif len(names_list) == self.m:
            self.input_feature_names = list(names_list)
        else:
            raise ValueError(f"Input feature names list length must be {self.m}, but got {len(names_list)}")

    def set_output_feature_names(self, names_list):
        if names_list is None:
            self.output_feature_names = [f"Output_{i+1}" for i in range(self.s)]
        elif len(names_list) == self.s:
            self.output_feature_names = list(names_list)
        else:
            raise ValueError(f"Output feature names list length must be {self.s}, but got {len(names_list)}")

    def save_results(self, file_path):
        if not file_path:
            print("Save operation canceled: No file path provided.")
            return
        if not file_path.lower().endswith(".pkl"):
            file_path += ".pkl"

        with open(file_path, "wb") as file:
            pickle.dump(self.results, file)
        print(f"Results saved to {file_path}")

    def fdh_input_crs(self):
        model_name = "fdh_input_crs"
        if model_name in self.results:
            return self.results[model_name]

        results_list = []

        base_model_gurobi = Model("FDH_Input_CRS_Base")
        base_model_gurobi.setParam(GRB.Param.OutputFlag, 0)

        for o in range(self.n):
            model = base_model_gurobi.copy() 

            z = model.addVars(self.n, vtype=GRB.BINARY, name="z")
            theta = model.addVar(lb=0, ub=1.0, name="theta") 
            delta = model.addVar(lb=0, name='delta')

            model.setObjective(theta, GRB.MINIMIZE)

            for i in range(self.m):
                model.addConstr(
                    delta * quicksum(z[j] * self.input_data[j, i] for j in range(self.n))
                    <= theta * self.input_data[o, i]
                )

            for r in range(self.s):
                model.addConstr(
                    quicksum(delta * z[j] * self.output_data[j, r] for j in range(self.n))
                    >= self.output_data[o, r]
                )

            model.addConstr(quicksum(z[j] for j in range(self.n)) == 1)

            model.optimize()

            if model.status == GRB.OPTIMAL:
                results_list.append({
                    "DMU": o,
                    "DMU_Name": self._get_dmu_name(o),
                    "efficiency": model.objVal
                })
            else:
                results_list.append({
                    "DMU": o,
                    "DMU_Name": self._get_dmu_name(o),
                    "efficiency": np.nan
                })

        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, model_name) 

        self.results[model_name] = results_df
        return results_df

    def fdh_output_crs(self):
        model_name = "fdh_output_crs"
        if model_name in self.results:
            return self.results[model_name]

        results_list = []

        for o in range(self.n):
            model = Model(f"FDH_Output_CRS_DMU_{o}")
            model.setParam(GRB.Param.OutputFlag, 0)

            z = [model.addVar(vtype=GRB.BINARY, name=f"z_{j}") for j in range(self.n)]
            eta = model.addVar(lb=1, name="eta") 
            delta = model.addVar(lb=0, name='delta')

            model.setObjective(eta, GRB.MAXIMIZE)

            for i in range(self.m):
                model.addConstr(quicksum(delta * z[j] * self.input_data[j, i] for j in range(self.n)) <= self.input_data[o, i])

            for r in range(self.s):
                model.addConstr(quicksum(delta * z[j] * self.output_data[j, r] for j in range(self.n)) >= eta * self.output_data[o, r])

            model.addConstr(quicksum(z[j] for j in range(self.n)) == 1)

            model.optimize()

            if model.status == GRB.OPTIMAL:
                results_list.append({
                    "DMU": o,
                    "DMU_Name": self._get_dmu_name(o),
                    "efficiency": model.objVal
                })
            else:
                results_list.append({
                    "DMU": o,
                    "DMU_Name": self._get_dmu_name(o),
                    "efficiency": np.nan
                })

        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, model_name)
        self.results[model_name] = results_df
        return results_df

    def fdh_input_vrs(self):
        model_name = "fdh_input_vrs"
        if model_name in self.results:
            return self.results[model_name]

        results_list = []
        for o in range(self.n):
            model = Model(f"FDH_Input_VRS_DMU_{o}")
            model.setParam(GRB.Param.OutputFlag, 0)

            lambdas = [model.addVar(vtype=GRB.BINARY, name=f"lambda_{j}") for j in range(self.n)]
            theta = model.addVar(lb=0, ub=1.0, name="theta") 
            model.setObjective(theta, GRB.MINIMIZE)

            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)

            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) <= theta * self.input_data[o, i])

            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) >= self.output_data[o, r])

            model.optimize()

            if model.status == GRB.OPTIMAL:
                results_list.append({
                    "DMU": o,
                    "DMU_Name": self._get_dmu_name(o),
                    "efficiency": model.objVal
                })
            else:
                results_list.append({
                    "DMU": o,
                    "DMU_Name": self._get_dmu_name(o),
                    "efficiency": np.nan
                })

        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, model_name)
        self.results[model_name] = results_df
        return results_df

    def fdh_output_vrs(self):
        model_name = "fdh_output_vrs"
        if model_name in self.results:
            return self.results[model_name]

        results_list = []
        for o in range(self.n):
            model = Model(f"FDH_Output_VRS_DMU_{o}")
            model.setParam(GRB.Param.OutputFlag, 0)

            lambdas = [model.addVar(vtype=GRB.BINARY, name=f"lambda_{j}") for j in range(self.n)]
            eta = model.addVar(lb=1, name="eta") 

            model.setObjective(eta, GRB.MAXIMIZE)

            for i in range(self.m):
                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) <= self.input_data[o, i])

            for r in range(self.s):
                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) >= eta * self.output_data[o, r])

            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)

            model.optimize()

            if model.status == GRB.OPTIMAL:
                results_list.append({
                    "DMU": o,
                    "DMU_Name": self._get_dmu_name(o),
                    "efficiency": model.objVal
                })
            else:
                results_list.append({
                    "DMU": o,
                    "DMU_Name": self._get_dmu_name(o),
                    "efficiency": np.nan
                })

        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, model_name)
        self.results[model_name] = results_df
        return results_df

    def plot_fdh(self, typ):  

        if self.input_data.shape[1] != 1 or self.output_data.shape[1] != 1:
            raise ValueError("Unsupported combination of M and S")

        x = self.input_data.flatten()
        y = self.output_data.flatten()
        dmu_names = [self._get_dmu_name(i) for i in range(len(x))]

        import matplotlib.pyplot as plt
        import numpy as np

        fig, ax = plt.subplots(figsize=(8, 6))
        ax.set_xlabel('Input')
        ax.set_ylabel('Output')
        ax.set_title('Input vs Output (FDH)')

        ax.scatter(x, y, c='blue', edgecolor='k', alpha=0.7)

        typ2func = {
            'fdh_input_vrs': self.fdh_input_vrs,
            'fdh_output_vrs': self.fdh_output_vrs,
        }
        if typ not in typ2func:
            raise ValueError(f"Unsupported type: {typ}")
        if typ not in self.results:
            self.results[typ] = typ2func[typ]()
        results = self.results[typ]

        efficient_idx = np.where(results['is_efficient'])[0]
        for i in efficient_idx:

            circ = plt.Circle((x[i], y[i]), radius=0.01 * max(x.max(), y.max()),
                              fill=False, edgecolor='red', linewidth=2)
            ax.add_artist(circ)

        for i, (xi, yi, name) in enumerate(zip(x, y, dmu_names)):
            ax.text(xi, yi, name, fontsize=8, color='gray',
                    ha='right', va='bottom')

        eff_points = list(zip(x[efficient_idx], y[efficient_idx]))
        if len(eff_points) > 1:

            eff_points = sorted(eff_points, key=lambda p: (p[0], -p[1]))
            xs, ys = zip(*eff_points)

            for j in range(len(xs) - 1):
                ax.hlines(ys[j], xs[j], xs[j+1], colors='green', linewidth=1)
                ax.vlines(xs[j+1], ys[j+1], ys[j], colors='green', linewidth=1)

            ax.hlines(ys[-1], xs[-1], x.max() * 1.1, colors='green', linewidth=1)
            ax.vlines(xs[0], 0, ys[0], colors='green', linewidth=1)

        ax.set_xlim(0, x.max() * 1.1)
        ax.set_ylim(0, y.max() * 1.1)
        ax.grid(True, linestyle='--', alpha=0.5)
        plt.tight_layout()
        # plt.show()
        return fig  # Return the figure instead of showing it


    def rdm_fdh(self):
        model_name = "rdm_fdh"
        if model_name in self.results:
            return self.results[model_name]

        results_list = []

        min_inputs_overall = np.min(self.input_data, axis=0)
        max_outputs_overall = np.max(self.output_data, axis=0)

        for o in range(self.n):
            model = Model(f"RDM_FDH_DMU_{o}")
            model.setParam(GRB.Param.OutputFlag, 0)

            R_minus_o = self.input_data[o, :] - min_inputs_overall

            R_plus_o = max_outputs_overall - self.output_data[o, :]

            lambdas = [model.addVar(vtype=GRB.BINARY, name=f"lambda_{j}") for j in range(self.n)]
            beta = model.addVar(lb=0, ub=1, name="beta") 

            model.setObjective(1 - beta, GRB.MINIMIZE) 

            for i in range(self.m):

                model.addConstr(quicksum(lambdas[j] * self.input_data[j, i] for j in range(self.n)) 
                                <= self.input_data[o, i] - beta * R_minus_o[i])

            for r in range(self.s):

                model.addConstr(quicksum(lambdas[j] * self.output_data[j, r] for j in range(self.n)) 
                                >= self.output_data[o, r] + beta * R_plus_o[r])

            model.addConstr(quicksum(lambdas[j] for j in range(self.n)) == 1)
            model.optimize()

            efficiency_val = np.nan
            if model.status == GRB.OPTIMAL:
                efficiency_val = model.ObjVal 

                if abs(efficiency_val) < 1e-9: 
                    efficiency_val = 0.0
                elif abs(efficiency_val - 1.0) < 1e-9: 
                    efficiency_val = 1.0

            results_list.append({
                "DMU": o,
                "DMU_Name": self._get_dmu_name(o),
                "efficiency": efficiency_val 
            })

        results_df = pd.DataFrame(results_list)
        results_df = is_efficient(results_df, model_name) 
        self.results[model_name] = results_df
        return results_df

    def predict(self, x, model_name):
        if model_name not in self.results:
            raise ValueError(f"Model {model_name} has not been computed yet.")
        x = np.array(x)
        model_results = self.results[model_name]

        valid_dmus = []
        for i in range(self.n):
            if model_results.loc[i, 'is_efficient'] and np.all(self.input_data[i] <= x):
                valid_dmus.append(i)

        if not valid_dmus:
            return 0

        max_output = np.max(self.output_data[valid_dmus], axis=0)

        return max_output.item()

================
File: models/modelsNH.py
================
from gurobipy import Model, GRB, quicksum, LinExpr
import pandas as pd
import numpy as np
from utils.is_efficient import is_efficient
from .modelsDEA import DEA
from utils.groupDMUs import groupDMUs

class Non_Homo:
    def __init__(self, input_data, output_data):
        self.input_data = input_data
        self.output_data = output_data
        self.n, self.m = input_data.shape
        self.s = output_data.shape[1]
        self.results = []
        self.N, self.R, self.dmu_outputs, self.correspondingR, self.L, self.dmu_to_subgroup, self.M = groupDMUs(self.output_data)
        self.alphas = []

    def no2mat(self, a, b):
        A = np.full((self.m, len(self.R), len(self.N)), a)
        B = np.full((self.m, len(self.R), len(self.N)), b)
        return A, B

    def compute_alphas(self, a, b):
        if self.alphas:
            return self.alphas

        alphas = []

        for knot in range(self.n):
            model = Model("non_homo_crs")
            gamma = {}

            for i in range(self.m):
                for k in range(len(self.R)):  
                    for p in range(len(self.N)):  
                        gamma[(i, k, p)] = model.addVar(vtype=GRB.CONTINUOUS, lb=0)

            for i in range(self.m):
                for np_j in range(len(self.N)):
                    L_np = self.L[np_j]
                    for k in range(len(self.R)):
                        if k not in L_np:
                            model.addConstr(gamma[(i, k, np_j)] == 0)

            for i in range(self.m):
                for np_j in range(len(self.N)):
                    L_np = self.L[np_j]
                    for k in range(len(self.R)):
                        if k in L_np:
                            model.addConstr(gamma[(i, k, np_j)] >= 1e-6)

            model.setParam(GRB.Param.OutputFlag, 0)

            mu = [model.addVar(lb=1e-6, name=f"mu_{r}") for r in range(self.s)]
            v = [model.addVar(lb=1e-6, name=f"v_{i}") for i in range(self.m)]

            npo = self.dmu_to_subgroup[knot]
            L_npo = self.L[npo]

            eo = LinExpr()
            for k in L_npo:
                for r in list(self.R[k]):
                    eo += mu[r] * self.output_data[knot, r]
            model.setObjective(eo, GRB.MAXIMIZE)

            norm_expr = LinExpr()
            for k in L_npo:
                for i in range(self.m):
                    norm_expr += gamma[(i, k, npo)] * self.input_data[knot, i]
            model.addConstr(norm_expr == 1, name="Normalization")

            for j in range(self.n):
                np_j = self.dmu_to_subgroup[j]
                L_np = list(self.L[np_j])

                for k in L_np:
                    output_expr = LinExpr()
                    input_expr = LinExpr()

                    for r in list(self.R[k]):
                        output_expr += mu[r] * self.output_data[j, r]

                    for i in range(self.m):
                        input_expr += gamma[(i, k, np_j)] * self.input_data[j, i]

                    model.addConstr(output_expr - input_expr <= 0, name=f"Constraint_Rk_{k}")

            for i in range(self.m):
                for np_j in range(len(self.N)):
                    L_np = list(self.L[np_j])
                    bound_inp = LinExpr()
                    for k in L_np:
                        bound_inp += gamma[(i, k, np_j)]
                    model.addConstr(bound_inp == v[i])

            for i in range(self.m):
                for np_j in range(len(self.N)):
                    for k in list(self.L[np_j]):
                        model.addConstr(a[i, k, np_j] * v[i] <= gamma[(i, k, np_j)])
                        model.addConstr(gamma[(i, k, np_j)] <= v[i] * b[i, k, np_j])

            model.optimize()

            if model.status == GRB.OPTIMAL:
                print("Optimal solution found.")
            elif model.status == GRB.INFEASIBLE:
                print("Model is infeasible.")
            elif model.status == GRB.UNBOUNDED:
                print("Model is unbounded.")
            elif model.status == GRB.TIME_LIMIT:
                print("Time limit reached.")
            elif model.status == GRB.INTERRUPTED:
                print("Optimization interrupted.")
            elif model.status == GRB.SUBOPTIMAL:
                print("Suboptimal solution found.")
            else:
                print("Optimization ended with an unknown status.")

            alphas.append({
                "DMU": knot,
                "alphas": {key: (gamma[key].x) / (v[key[0]].x) for key in gamma if key[2] == self.dmu_to_subgroup[knot]}
            })

            self.alphas = alphas
        return alphas

    def new_input_data(self):
        if self.alphas:
            alphas = self.alphas
        else:
            raise Exception("compute alphas first")

        new_input_data = np.zeros((self.n, self.m, len(self.R)))
        for j in range(self.n):
            alpha_values = alphas[j]['alphas'].items()

            for (i, k, p) , alpha in alpha_values:
                new_input_data[j, i, k] = alpha * self.input_data[j, i]
        return new_input_data

    def average_efficiency(self, new_input_data):
        if self.results:
            return self.results[0]
        
        efficiencyvals = {i:0 for i in range(self.input_data.shape[0])}
        rep = {i : 0 for i in range(self.input_data.shape[0])}

        for k in range(len(self.R)):
            for dmu in list(self.M[k]):
                rep[dmu] += 1

            x_dash = new_input_data[list(self.M[k]) , : , k]
            y_dash = self.output_data[list(self.M[k]), :] 
            y_dash = y_dash[:, list(self.R[k])]

            dea = DEA(x_dash, y_dash)

            ccr_res = dea.ccr_input()[["DMU", 'efficiency']]

            reindexed_dmus = {idx: dmu for idx, dmu in enumerate(self.M[k])}

            for idx in ccr_res["DMU"]:
                original_dmu = reindexed_dmus[idx]
                efficiency_score = ccr_res.loc[ccr_res["DMU"] == idx, "efficiency"]
                if not efficiency_score.empty:
                    efficiencyvals[original_dmu] += efficiency_score.iloc[0]

        average_efficiencies = {dmu: efficiencyvals[dmu] / rep[dmu] for dmu in efficiencyvals}
        self.results.append(average_efficiencies)
        return average_efficiencies

================
File: utils/datainput.py
================
import numpy as np
import pandas as pd
import pickle
import tkinter as tk
from tkinter import filedialog
import matplotlib.pyplot as plt


def arr2matrix(x, y):
    input_data = np.array(x).T
    output_data = np.array(y).T
    return input_data, output_data


def load_results():
    root = tk.Tk()
    root.withdraw()  
    file_path = filedialog.askopenfilename(
        filetypes=[("Pickle files", "*.pkl"), ("All files", "*.*")]
    )
    if file_path:  
        with open(file_path, "rb") as file:
            results = pickle.load(file)
        print(f"Results loaded from {file_path}")
        return results
    else:
        print("Load operation canceled.")
        return None
    

def xlsx2matrix(file_path, x, y):
    df = pd.read_excel(file_path)

    input_data = df[x].to_numpy()
    output_data = df[y].to_numpy()

    input_data[np.isnan(input_data)] = 0
    output_data[np.isnan(output_data)] = 0

    return input_data, output_data


def csv2matrix(file_path, x, y):
    df = pd.read_csv(file_path)

    input_data = df[x].to_numpy()
    output_data = df[y].to_numpy()

    input_data[np.isnan(input_data)] = 0
    output_data[np.isnan(output_data)] = 0

    return input_data, output_data



def initializeUnif(N, M, S, a, b):    
    input_array = np.random.uniform(a, b, size=(N, M))
    output_array = np.random.uniform(a, b, size=(N, S))
    return input_array, output_array


def initialize_sparse(N, M, S, a, b, density):
    if not (0 < density <= 1):
        raise ValueError("Density must be between 0 and 1.")

    input_array = np.random.uniform(a, b, size=(N, M))

    output_array = np.random.uniform(a, b, size=(N, S))
    mask = np.random.rand(N, S) < density
    output_array = output_array * mask
    plt.figure(figsize=(8, 6))
    plt.imshow(output_array == 0, cmap="Grays", interpolation="none", aspect='auto')
    plt.xlabel("Columns")
    plt.ylabel("Rows")
    plt.show()
    
    return input_array, output_array

================
File: utils/groupDMUs.py
================
import numpy as np
from collections import defaultdict


def groupDMUs(y):
    n, s = y.shape
    dmu_outputs = {}
    profile_to_dmus = defaultdict(set)
    profile_to_outputs = defaultdict(set)
    correspondingR = {}

    for dmu in range(n):
        produced_outputs = {output for output in range(s) if y[dmu, output] != 0}
        dmu_outputs[dmu] = produced_outputs
        profile_to_dmus[frozenset(produced_outputs)].add(dmu)

    N = list(profile_to_dmus.values())  

    for output in range(s):
        producing_dmus = {dmu for dmu in range(n) if y[dmu, output] != 0}
        profile_to_outputs[frozenset(producing_dmus)].add(output)

    R = list(profile_to_outputs.values())  

    for i, output_set in enumerate(R):
        for output in output_set:
            correspondingR[output] = i

    L = {}
    dmu_to_subgroup = {}

    for i, dmu_group in enumerate(N):
        L[i] = set()  
        for dmu in dmu_group:

            L[i].update(correspondingR[output] for output in dmu_outputs[dmu])
            dmu_to_subgroup[dmu] = i 
            
    M = [set() for _ in range(len(R))]
    for dmu, outputs in dmu_outputs.items():
        for output in outputs:
            k = correspondingR[output]
            M[k].add(dmu)

    return N, R, dmu_outputs, correspondingR, L, dmu_to_subgroup, M

================
File: utils/is_efficient.py
================
import numpy as np

def is_efficient(results, efficiency_type):
    if efficiency_type == 'ccr_input':
        slacks_minus_zero = np.array([np.all(np.array(s) == 0) for s in results['slacks_minus']])
        slacks_plus_zero = np.array([np.all(np.array(s) == 0) for s in results['slacks_plus']])

        results['is_efficient'] = ((results['efficiency'] == 1) &
                                   np.logical_and(slacks_minus_zero, slacks_plus_zero))
    elif efficiency_type == 'ccr_output':
        t_minus_zero = np.array([np.all(np.array(t) == 0) for t in results['t_minus']])
        t_plus_zero = np.array([np.all(np.array(t) == 0) for t in results['t_plus']])

        results['is_efficient'] = ((results['n'] == 1) &
                                   np.logical_and(t_minus_zero, t_plus_zero))
    elif efficiency_type == 'bcc_input':
        slacks_minus_zero = np.array([np.all(np.array(s) == 0) for s in results['slacks_minus']])
        slacks_plus_zero = np.array([np.all(np.array(s) == 0) for s in results['slacks_plus']])

        results['is_efficient'] = ((results['efficiency'] == 1) &
                                   np.logical_and(slacks_minus_zero, slacks_plus_zero))
    elif efficiency_type == 'bcc_output':
        t_minus_zero = np.array([np.all(np.array(t) == 0) for t in results['t_minus']])
        t_plus_zero = np.array([np.all(np.array(t) == 0) for t in results['t_plus']])

        results['is_efficient'] = ((results['n'] == 1) &
                                   np.logical_and(t_minus_zero, t_plus_zero))

    elif efficiency_type == 'add':
        slacks_minus_zero = np.array([np.all(np.array(s) == 0) for s in results['slacks_minus']])
        slacks_plus_zero = np.array([np.all(np.array(s) == 0) for s in results['slacks_plus']])

        results['is_efficient'] = np.logical_and(slacks_minus_zero, slacks_plus_zero)

    elif efficiency_type == 'sbm':
        results['is_efficient'] = (results['rho'] == 1)

    elif efficiency_type == 'sbm_non_oriented':
        results['is_efficient'] = (results['rho'] == 1)
    elif efficiency_type == 'sbm_input':
        results['is_efficient'] = (results['rho'] == 1)
    elif efficiency_type == 'sbm_output':
        results['is_efficient'] = (results['rho'] == 1)
    elif efficiency_type == 'modified_sbm':
        results['is_efficient'] = (results['rho'] == 1)


    elif efficiency_type == 'fdh_input_crs':
        results['is_efficient'] = (results['efficiency'] == 1)

    elif efficiency_type == 'fdh_output_crs':
        results['is_efficient'] = (results['efficiency'] == 1)
        
    elif efficiency_type == 'fdh_input_vrs':
        results['is_efficient'] = (results['efficiency'] == 1)

    elif efficiency_type == 'fdh_output_vrs':
        results['is_efficient'] = (results['efficiency'] == 1)
    
    elif efficiency_type == 'rdm':
        results['is_efficient'] = (results['efficiency'] == 1)
        
    elif efficiency_type == 'rdm_fdh':
        results['is_efficient'] = (results['efficiency'] == 1)
    else:
        raise ValueError(f"Unknown efficiency type: {efficiency_type}")

    return results

================
File: utils/li_test.py
================
import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize

def continuous_kernel(u, bandwidth):
    return np.exp(-(u ** 2) / (2 * bandwidth ** 2)) / (np.sqrt(2 * np.pi) * bandwidth)

def discrete_kernel(x_i, x_j, c):
    return 1 if np.array_equal(x_i, x_j) else 0

def product_kernel(sample1, sample2, bandwidth, continuous_idx, discrete_idx, c=0.5):
    kernel_vals = 1
    for idx in continuous_idx:
        kernel_vals *= continuous_kernel(sample1[idx] - sample2[idx], bandwidth[idx])
    for idx in discrete_idx:
        kernel_vals *= discrete_kernel(sample1[idx], sample2[idx], c)
    return kernel_vals

def compute_kernel_matrix(data, bandwidth, continuous_idx, discrete_idx):
    n = data.shape[0]
    kernel_matrix = np.ones((n, n))
    
    for i in range(n):
        for j in range(i + 1, n):
            kernel_matrix[i, j] = product_kernel(data[i], data[j], bandwidth, continuous_idx, discrete_idx)
            kernel_matrix[j, i] = kernel_matrix[i, j]  
    np.fill_diagonal(kernel_matrix, 0)
    return kernel_matrix


def kernel_conv_cont(u, bandwidth):
    return np.exp(-(u**4) / (2 * bandwidth**2)) / (np.sqrt(4 * np.pi) * bandwidth)


def compute_cross_kernel_matrix(X, Y, bandwidth, continuous_idx, discrete_idx):
    n1, n2 = len(X), len(Y)
    cross_kernel_matrix = np.ones((n1, n2))
    
    for i in range(n1):
        for j in range(n2):
            kernel_val = 1
            for idx in continuous_idx:
                u = (X[i][idx] - Y[j][idx]) / bandwidth[idx]
                kernel_val *= continuous_kernel(u, bandwidth[idx])
            
            for idx in discrete_idx:
                kernel_val *= discrete_kernel(X[i][idx], Y[j][idx], c=0.5)
            
            cross_kernel_matrix[i, j] = kernel_val
    
    return cross_kernel_matrix


def lscv(bandwidth, data, continuous_idx, discrete_idx):
    n = len(data)
    total_error = 0
    for i in range(n):
        leave_out_data = np.delete(data, i, axis=0)
        density = product_kernel(data[i], leave_out_data, bandwidth, continuous_idx, discrete_idx)
        total_error += density ** 2
    return total_error / n - 2 * np.mean(density)

def select_bandwidth(data, continuous_idx, discrete_idx):
    initial_bandwidth = 1.06 * np.std(data, axis=0) * len(data) ** (-1/5)
    result = minimize(lscv, initial_bandwidth, args=(data, continuous_idx, discrete_idx), method='L-BFGS-B')
    return result.x

def compute_test_statistic(X, Y, bandwidth, continuous_idx, discrete_idx):
    n1, n2 = len(X), len(Y)
    KXX = compute_kernel_matrix(X, bandwidth, continuous_idx, discrete_idx)
    KYY = compute_kernel_matrix(Y, bandwidth, continuous_idx, discrete_idx)
    KXY = compute_cross_kernel_matrix(X, Y, bandwidth, continuous_idx, discrete_idx)
    
    I_X = np.sum(KXX) / (n1 * (n1 - 1))
    I_Y = np.sum(KYY) / (n2 * (n2 - 1))
    I_XY = np.sum(KXY) / (n1 * n2)
    I = I_X + I_Y - 2 * I_XY
    
    Omega = 2 * n1 * n2 * np.prod(bandwidth) * (
        (np.sum(KXX**2) / (n1**2 * (n1 - 1)**2)) +
        (np.sum(KYY**2) / (n2**2 * (n2 - 1)**2)) +
        (np.sum(KXY**2) / (n1**2 * n2**2))
    )
    
    Tn = np.sqrt(n1 * n2 * np.prod(bandwidth)) * I / np.sqrt(Omega)
    return Tn

def bootstrap_test(X, Y, bandwidth, continuous_idx, discrete_idx, n_boot):
    combined_data = np.vstack((X, Y))
    Tn_observed = compute_test_statistic(X, Y, bandwidth, continuous_idx, discrete_idx)
    
    Tn_bootstrap = []
    for _ in range(n_boot):
        X_boot = combined_data[np.random.choice(len(combined_data), size=len(X), replace=True)]
        Y_boot = combined_data[np.random.choice(len(combined_data), size=len(Y), replace=True)]
        Tn_bootstrap.append(compute_test_statistic(X_boot, Y_boot, bandwidth, continuous_idx, discrete_idx))
    
    # p_value = np.mean(np.array(Tn_bootstrap) >= Tn_observed)
    p_value=(np.sum(np.array(Tn_bootstrap) >= Tn_observed) + 1) / (n_boot + 1)
    return p_value, Tn_observed

def li_test(X, Y, continuous_idx, discrete_idx, alpha=0.05, n_boot=2000):
    bandwidth = select_bandwidth(np.vstack((X, Y)), continuous_idx, discrete_idx)
    p_value, Tn_observed = bootstrap_test(X, Y, bandwidth, continuous_idx, discrete_idx, n_boot=n_boot)
    h = int(p_value <= alpha)
    return p_value, h, Tn_observed

